\documentclass[bsc,frontabs,twoside,singlespacing,parskip,deptreport]{infthesis}

\usepackage{agda}
\usepackage{catchfilebetweentags}
\usepackage{amsthm}

\input{commands}

%\usepackage{agda}

% The following packages are needed because unicode
% is translated (using the next set of packages) to
% latex commands. You may need more packages if you
% use more unicode characters:

% \usepackage{textgreek}
% \usepackage{amssymb}
% \usepackage{bbm}
% \usepackage[greek,english]{babel}
% \usepackage{amsthm}
% \usepackage{catchfilebetweentags}
% \usepackage{mathrsfs}

% This handles the translation of unicode to latex:

% \usepackage{ucs}
% \usepackage[utf8x]{inputenc}
% \usepackage{autofe}

% Some characters that are not automatically defined
% (you figure out by the latex compilation errors you get),
% and you need to define:

% \DeclareUnicodeCharacter{8988}{\ensuremath{\ulcorner}}
% \DeclareUnicodeCharacter{8989}{\ensuremath{\urcorner}}
% \DeclareUnicodeCharacter{8803}{\ensuremath{\overline{\equiv}}}
% \DeclareUnicodeCharacter{0411}{\ensuremath{\lambda}}
% \DeclareUnicodeCharacter{8718}{\ensuremath{\square}}
% \DeclareUnicodeCharacter{8759}{::}
% \DeclareUnicodeCharacter{10218}{\ensuremath{\langle\langle}}
% \DeclareUnicodeCharacter{10219}{\ensuremath{\rangle\rangle}}
% \DeclareUnicodeCharacter{120038}{\ensuremath{\mathcal{W}}}
% \DeclareUnicodeCharacter{7473}{\textsuperscript{E}}

% Add more as you need them (shouldn't happen often). 

\theoremstyle{definition}
\newtheorem*{definition}{Definition}

\begin{document}

\title{Type-preserving closure conversion of PCF in Agda (more to come)}

\author{Piotr Jander}

\course{Master of Informatics}
\project{{\bf MInf Project (Part 2) Report}}

\date{\today}

\abstract{
This is an example of {\tt infthesis} style.
The file {\tt skeleton.tex} generates this document and can be
used to get a ``skeleton'' for your thesis.
The abstract should summarise your report and fit in the space on the
first page.
%
You may, of course, use any other software to write your report,
as long as you follow the same style. That means: producing a title
page as given here, and including a table of contents and bibliography.
}

\maketitle

\section*{Acknowledgements}
Acknowledgements go here.

\tableofcontents

%\pagenumbering{arabic}


\chapter{Introduction}

The document structure should include:
\begin{itemize}
\item
The title page  in the format used above.
\item
An optional acknowledgements page.
\item
The table of contents.
\item
The report text divided into chapters as appropriate.
\item
The bibliography.
\end{itemize}

Commands for generating the title page appear in the skeleton file and
are self explanatory.
The file also includes commands to choose your report type (project
report, thesis or dissertation) and degree.
These will be placed in the appropriate place in the title page.

The default behaviour of the documentclass is to produce documents typeset in
12 point.  Regardless of the formatting system you use,
it is recommended that you submit your thesis printed (or copied)
double sided.

The report should be printed single-spaced.
It should be 30 to 60 pages long, and preferably no shorter than 20 pages.
Appendices are in addition to this and you should place detail
here which may be too much or not strictly necessary when reading the relevant section.

\section{Using Sections}

Divide your chapters into sub-parts as appropriate.

\section{Citations}

Note that citations
(like \cite{P1} or \cite{P2})
can be generated using {\tt BibTeX} or by using the
{\tt thebibliography} environment. This makes sure that the
table of contents includes an entry for the bibliography.
Of course you may use any other method as well.

\section{Options}

There are various documentclass options, see the documentation.  Here we are
using an option ({\tt bsc} or {\tt minf}) to choose the degree type, plus:
\begin{itemize}
\item {\tt frontabs} (recommended) to put the abstract on the front page;
\item {\tt twoside} (recommended) to format for two-sided printing, with
  each chapter starting on a right-hand page;
\item {\tt singlespacing} (required) for single-spaced formating; and
\item {\tt parskip} (a matter of taste) which alters the paragraph formatting so that
paragraphs are separated by a vertical space, and there is no
indentation at the start of each paragraph.
\end{itemize}






\chapter{Background}

\section{Type- and scope-safe representation}

This project uses a number a languages and intermediate languages,
which are variations of the simply-typed lambda calculus
(STLC). Representations of those languages share two
characteristics. They are scope-safe in the sense that every variables
of a term is either bound by some binder, or it is explicitly
accounted for in the context \cite{DBLP:journals/pacmpl/AllaisA0MM18}.
They are type-safe in the sense that terms are represented by their
typing derivation, so that ill-typed terms are not representable
\cite{DBLP:conf/pldi/Chlipala07}.

To see how type and scope safety is achieved in this project, it is
useful to analyse our Agda encoding of STLC. The encoding uses
dependently-typed de Bruijn variables which are proofs of context
membership, and inherently-typed terms.

TODO STLC as a figure here

STLC has base types and function types.

\ExecuteMetaData[Common.tex]{type}

The context is simply a list of types.

\ExecuteMetaData[Common.tex]{context}

Variables are synonymous with proofs of context membership, hence the
name \AS{\_‚àã\_}. Since a variable is identified by its position in
the context, it is appropriate to call it a de~Bruijn
variable. Accordingly, the \AS{\_‚àã\_} constructors are called after
\textit{zero} and \textit{successor}. Notice that this definition
assume that the leftmost type in the context corresponds to the most
recently bound variable.

\ExecuteMetaData[Common.tex]{var}

We can now present the formulation of STLC terms:

\ExecuteMetaData[STLC.tex]{terms}

The syntactic variable \AS{`\_} constructor takes variables to
terms. The abstraction constructor \AS{Œª\_} requires that the body is
well-typed in the context \AS{Œì} extended with the type \AS{A} of the
variable bound by the abstraction. The application constructor
\AS{\_¬∑\_} follows the typing rule for application.

This is the Altenkirch and Reus' STLC
representation. \cite{DBLP:conf/csl/AltenkirchR99}.

\section{Type- and scope-safe programs}

TODO read about HOAS

Many useful traversals of the abstract syntax tree involve maintaining
a mapping from free variables to appropriate values. Two such
traversals are sumultaneous renaming and substitution.

Simultaneous renaming takes a term in the context \AS{Œì}. It maintains
a mapping from variables in original context \AS{Œì} to variables in
some other context \AS{Œî}. (TODO elaborate on renamings later). It
produces a term in \AS{Œî}.

Similarly, simultaneous substitution takes a term in the context
\AS{Œì}. It maintains a mapping from variables in original context
\AS{Œì} to terms in some other context \AS{Œî}. It produces a term in
\AS{Œî}.

Before we can give an implementation of renaming and substitution, we
need to formalise the notion of a mapping from free variables to
appropriate values, which we call the \textit{environment}.

\ExecuteMetaData[STLC.tex]{env}

A environment \AS{(Œì ‚îÄEnv) ùì• Œî} encapsulates a mapping from variables in
\AS{Œì} to values \AS{ùì•} (variables for renaming, terms for
substitution) which are well-type and -scoped in \AS{Œî}.

Environments which map to variables or terms are important enough to
deserve their own names.

\ExecuteMetaData[STLC.tex]{thinningsubst}

There is a notion of an empty environment \AS{Œµ}, of extending an
environment \AS{œÅ} with a value \AS{v}: \AS{œÅ ‚àô v}, and of mapping a
function \AS{f} over an environment \AS{œÅ}: \AS{f <\$> œÅ},
corresponding to the analogous operations on contexts (which are just
lists).

\ExecuteMetaData[STLC.tex]{envops}

Notice that those three operations on environments are defined using
copatterns \cite{DBLP:conf/popl/AbelPTS13} by `observing` the
behaviour of \AS{lookup}.

Equipped with the notion of environments, we can give an
implementation of renaming and substitution:

\ExecuteMetaData[STLC.tex]{rename}
\ExecuteMetaData[STLC.tex]{subst}

Notice that those two implementation are indentical except (1)
renaming wraps the result of \AS{lookup œÅ x} in \AS{`\_}, and renaming
and substitution extend the environment in a different way: \AS{S\_ <\$>
  œÅ ‚àô Z} vs \AS{rename extend <\$> œÉ ‚àô ` Z}. The observation that
renaming and substitution for STLC share a common structure was a
basis was the unpublished manuscript by McBride
\cite{mcbride2005type}, and subsequently motivated the ACMM paper
\cite{DBLP:conf/cpp/Allais0MM17}. In section~??, we will show how ACMM
abstracts this common structure of renaming and substitution into a
notion of a semantics.

\section{TODO reductions, progress and preservation}

\section{TODO ACMM and semantics}

\section{TODO ACMM and synchronisation lemmas}

\section{TODO ACMM and fusion lemmas}



% use the following and \cite{} as above if you use BibTeX
% otherwise generate bibtem entries
\bibliographystyle{plain}
\bibliography{main}

\end{document}
