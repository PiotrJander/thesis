\documentclass[bsc,frontabs,twoside,singlespacing,parskip,deptreport]{infthesis}

\usepackage{agda}
\usepackage{catchfilebetweentags}
\usepackage{amsthm}

\input{commands}

%\usepackage{agda}

% The following packages are needed because unicode
% is translated (using the next set of packages) to
% latex commands. You may need more packages if you
% use more unicode characters:

% \usepackage{textgreek}
% \usepackage{amssymb}
% \usepackage{bbm}
% \usepackage[greek,english]{babel}
% \usepackage{amsthm}
% \usepackage{catchfilebetweentags}
% \usepackage{mathrsfs}

% This handles the translation of unicode to latex:

% \usepackage{ucs}
% \usepackage[utf8x]{inputenc}
% \usepackage{autofe}

% Some characters that are not automatically defined
% (you figure out by the latex compilation errors you get),
% and you need to define:

% \DeclareUnicodeCharacter{8988}{\ensuremath{\ulcorner}}
% \DeclareUnicodeCharacter{8989}{\ensuremath{\urcorner}}
% \DeclareUnicodeCharacter{8803}{\ensuremath{\overline{\equiv}}}
% \DeclareUnicodeCharacter{0411}{\ensuremath{\lambda}}
% \DeclareUnicodeCharacter{8718}{\ensuremath{\square}}
% \DeclareUnicodeCharacter{8759}{::}
% \DeclareUnicodeCharacter{10218}{\ensuremath{\langle\langle}}
% \DeclareUnicodeCharacter{10219}{\ensuremath{\rangle\rangle}}
% \DeclareUnicodeCharacter{120038}{\ensuremath{\mathcal{W}}}
% \DeclareUnicodeCharacter{7473}{\textsuperscript{E}}

% Add more as you need them (shouldn't happen often). 

\theoremstyle{definition}
\newtheorem*{definition}{Definition}

\begin{document}

\title{Type-preserving closure conversion of PCF in Agda (more to come)}

\author{Piotr Jander}

\course{Master of Informatics}
\project{{\bf MInf Project (Part 2) Report}}

\date{\today}

\abstract{
This is an example of {\tt infthesis} style.
The file {\tt skeleton.tex} generates this document and can be
used to get a ``skeleton'' for your thesis.
The abstract should summarise your report and fit in the space on the
first page.
%
You may, of course, use any other software to write your report,
as long as you follow the same style. That means: producing a title
page as given here, and including a table of contents and bibliography.
}

\maketitle

\section*{Acknowledgements}
Acknowledgements go here.

\tableofcontents

%\pagenumbering{arabic}


\chapter{Introduction}

The document structure should include:
\begin{itemize}
\item
The title page  in the format used above.
\item
An optional acknowledgements page.
\item
The table of contents.
\item
The report text divided into chapters as appropriate.
\item
The bibliography.
\end{itemize}

Commands for generating the title page appear in the skeleton file and
are self explanatory.
The file also includes commands to choose your report type (project
report, thesis or dissertation) and degree.
These will be placed in the appropriate place in the title page.

The default behaviour of the documentclass is to produce documents typeset in
12 point.  Regardless of the formatting system you use,
it is recommended that you submit your thesis printed (or copied)
double sided.

The report should be printed single-spaced.
It should be 30 to 60 pages long, and preferably no shorter than 20 pages.
Appendices are in addition to this and you should place detail
here which may be too much or not strictly necessary when reading the relevant section.

\section{Using Sections}

Divide your chapters into sub-parts as appropriate.

\section{Citations}

Note that citations
(like \cite{P1} or \cite{P2})
can be generated using {\tt BibTeX} or by using the
{\tt thebibliography} environment. This makes sure that the
table of contents includes an entry for the bibliography.
Of course you may use any other method as well.

\section{Options}

There are various documentclass options, see the documentation.  Here we are
using an option ({\tt bsc} or {\tt minf}) to choose the degree type, plus:
\begin{itemize}
\item {\tt frontabs} (recommended) to put the abstract on the front page;
\item {\tt twoside} (recommended) to format for two-sided printing, with
  each chapter starting on a right-hand page;
\item {\tt singlespacing} (required) for single-spaced formating; and
\item {\tt parskip} (a matter of taste) which alters the paragraph formatting so that
paragraphs are separated by a vertical space, and there is no
indentation at the start of each paragraph.
\end{itemize}






\chapter{Background}

\section{Type- and scope-safe representation}

This project uses a number a languages and intermediate languages,
which are variations of the simply-typed lambda calculus
(STLC). Representations of those languages share two
characteristics. They are scope-safe in the sense that every variables
of a term is either bound by some binder, or it is explicitly
accounted for in the context \cite{DBLP:journals/pacmpl/AllaisA0MM18}.
They are type-safe in the sense that terms are represented by their
typing derivation, so that ill-typed terms are not representable
\cite{DBLP:conf/pldi/Chlipala07}.

To see how type and scope safety is achieved in this project, it is
useful to analyse our Agda encoding of STLC. The encoding uses
dependently-typed de Bruijn variables which are proofs of context
membership, and inherently-typed terms.

TODO STLC as a figure here

STLC has base types and function types.

\ExecuteMetaData[Common.tex]{type}

The context is simply a list of types.

\ExecuteMetaData[Common.tex]{context}

Variables are synonymous with proofs of context membership, hence the
name \AS{\_‚àã\_}. Since a variable is identified by its position in
the context, it is appropriate to call it a de~Bruijn
variable. Accordingly, the \AS{\_‚àã\_} constructors are called after
\textit{zero} and \textit{successor}. Notice that this definition
assume that the leftmost type in the context corresponds to the most
recently bound variable.

\ExecuteMetaData[Common.tex]{var}

We can now present the formulation of STLC terms:

\ExecuteMetaData[STLC.tex]{terms}

The syntactic variable \AS{`\_} constructor takes variables to
terms. The abstraction constructor \AS{Œª\_} requires that the body is
well-typed in the context \AS{Œì} extended with the type \AS{A} of the
variable bound by the abstraction. The application constructor
\AS{\_¬∑\_} follows the typing rule for application.

This is the Altenkirch and Reus' STLC
representation. \cite{DBLP:conf/csl/AltenkirchR99}.

\section{Type- and scope-safe programs}

TODO read about HOAS

Many useful traversals of the abstract syntax tree involve maintaining
a mapping from free variables to appropriate values. Two such
traversals are sumultaneous renaming and substitution.

Simultaneous renaming takes a term in the context \AS{Œì}. It maintains
a mapping from variables in original context \AS{Œì} to variables in
some other context \AS{Œî}. (TODO elaborate on renamings later). It
produces a term in \AS{Œî}.

Similarly, simultaneous substitution takes a term in the context
\AS{Œì}. It maintains a mapping from variables in original context
\AS{Œì} to terms in some other context \AS{Œî}. It produces a term in
\AS{Œî}.

Before we can give an implementation of renaming and substitution, we
need to formalise the notion of a mapping from free variables to
appropriate values, which we call the \textit{environment}.

\ExecuteMetaData[STLC.tex]{env}

A environment \AS{(Œì ‚îÄEnv) ùì• Œî} encapsulates a mapping from variables in
\AS{Œì} to values \AS{ùì•} (variables for renaming, terms for
substitution) which are well-type and -scoped in \AS{Œî}.

Environments which map to variables or terms are important enough to
deserve their own names.

\ExecuteMetaData[STLC.tex]{thinningsubst}

There is a notion of an empty environment \AS{Œµ}, of extending an
environment \AS{œÅ} with a value \AS{v}: \AS{œÅ ‚àô v}, and of mapping a
function \AS{f} over an environment \AS{œÅ}: \AS{f <\$> œÅ},
corresponding to the analogous operations on contexts (which are just
lists).

\ExecuteMetaData[STLC.tex]{envops}

Notice that those three operations on environments are defined using
copatterns \cite{DBLP:conf/popl/AbelPTS13} by `observing` the
behaviour of \AS{lookup}.

Equipped with the notion of environments, we can give an
implementation of renaming and substitution:

\ExecuteMetaData[STLC.tex]{rename}
\ExecuteMetaData[STLC.tex]{subst}

Notice that those two implementation are indentical except (1)
renaming wraps the result of \AS{lookup œÅ x} in \AS{`\_}, and renaming
and substitution extend the environment in a different way: \AS{S\_ <\$>
  œÅ ‚àô Z} vs \AS{rename extend <\$> œÉ ‚àô ` Z}. The observation that
renaming and substitution for STLC share a common structure was a
basis was the unpublished manuscript by McBride
\cite{mcbride2005type}, and subsequently motivated the ACMM paper
\cite{DBLP:conf/cpp/Allais0MM17}. In section~??, we will show how ACMM
abstracts this common structure of renaming and substitution into a
notion of a semantics.

\section{TODO reductions, progress and preservation}

\section{TODO ACMM and semantics}

\section{TODO ACMM and synchronisation lemmas}

\section{TODO ACMM and fusion lemmas}

\chapter{TODO Target language}

\section{Renaming and substitution}

\chapter{TODO Minimising closure conversion}

\chapter{Bisimulation}

In the previous chapters, we defined the source and target languages
of the closure conversion, together with reduction rules for each, and
a translation function from source to target.

Our implementation of closure conversion is type and scope-preserving
by construction. The property of type preservation would be considered
a strong indication of correctness in a real-world compiler, but in
this theoretical development which deals with a small, toy language,
we prove stronger correctness properties which speak about operation
correctness.

One such property of operational correctness of a pair of languages is
bisimulation. Intuition about bisimulation is captured by a slogan:
pairwise similar terms reduce to pairwise similar terms. 

\section{Similarity relation}

Before we can precisely define
bisimulation, we need a definition of similarity between source
and target terms of closure conversion.

\ExecuteMetaData[StateOfTheArt/Bisimulation.tex]{tilde}

\begin{definition}
  Given a source language term \AS{M} and a target language term \AS{M‚Ä†},
  the similarity relation \AS{M \ti M‚Ä†} is defined inductively as
  follows:

  \begin{itemize}
  \item
    (Variable) For any given variable (proof of context membership) \AS{x}, we have
    \AS{S.` x \ti T.` x}.

  \item
    (Application) If \AS{M \ti M‚Ä†} and \AS{N \ti N‚Ä†},
    then \AS{M S.¬∑ N \ti M‚Ä† T.¬∑ N‚Ä†}.

  \item
    (Abstraction) If \AS{N \ti T.subst (T.exts E) N‚Ä†},
    then \AS{Œª N \ti ‚ü™ N‚Ä† , E ‚ü´}.
  \end{itemize}
\end{definition}

We unpack the definition here. Recall that in our definition of
closure conversion, source and target languages share the same (meta)
type of (object) types, contexts, and variables (proofs of context
membership). In fact, similarity is only defined for source and target
terms of the same type in the same context (this is explicit in the Agda
definition). 

Therefore, similarity of (syntactic) variables can be defined in terms
of identity of proofs of membership.

Similarity of applications is defined by congruence.

Finally, the non-trivial case of abstractions. What are the necessary
conditions for \AS{Œª N \ti ‚ü™ N‚Ä† , E ‚ü´}, where \AS{Œª N} and 
\AS{‚ü™ N‚Ä† , E ‚ü´} are defined in context \AS{Œì}? Clearly, we cannot require
that \AS{N \ti N‚Ä†}, as the context \AS{Œî} in which the closure body is
defined is existentially quantified. However, recall that the closure environment
\AS{E} is defined as a substitution from \AS{Œî} to \AS{Œì}. Applying
this substitution to the closure body (\AS{T.subst (T.exts E) N‚Ä†})
results in a term in \AS{Œì} which can be in a similarity relation with
\AS{N}, and this is precisely what we require in the definition.

(Note: the \AS{exts} accounts for the fact that the closure body is
defined in the context \AS{Œî} extended by the variable bound by the
abstraction, similarly to the lambda body.)

It is natural to ask what the relationship between a closure
conversion function and the similarity relation. Is the similarity
relation as graph relation of a closure conversion function? It is
not. Recall that closure conversion can be implemented by any function
which takes source terms to target terms and preserves the type and
context. But an implementation has freedom in how it deals with
closure environments; the meta language type of closures only requires
that the environment is \textit{some} substitution from the closure
body context \AS{Œî} to the outer context \AS{Œì}.

For example, the closure conversion transformation we described in
Chapter ??? had the property that closure environments were minimal:
they only contained parts of context actually used by the closure
body. In contrast, the simplest possible closure conversion could use
identity environments:

\ExecuteMetaData[StateOfTheArt/Bisimulation.tex]{convert}

We require that for every well-behaved closure conversion function \AS{c}, any
source term \AS{N} is similar to the result of its translation with
\AS{c}: \AS{N \ti c N}. This is indeed the case for the \AS{convert}
function. The proof is by straightforward induction; in the
abstraction case, we need to argue that applying an identity substitution
leaves the term unchanged.

\ExecuteMetaData[StateOfTheArt/Bisimulation.tex]{graph}

A similar result could be obtained for the closure conversion
algorithm which minimises environments from Chapter ???, but the proof
would be longer.

However, given \AS{M \ti M‚Ä†}, it is not
necessarily the case that \AS{M‚Ä† ‚â° c M} for any \textit{fixed}
function \AS{c}; instead, \AS{M‚Ä† ‚â° c M} holds for \textit{some}
function \AS{c}. Therefore, the similarity relation is not the graph
relation of any \textit{specific} conversion \AS{c}.

Having defined the notion of similarity, we are in a position to
define bisimulation.

\section{Bisimulation}

Bisimulation is a two-way property which is defined in terms of a
simpler one-way property of simulation.

\begin{definition}{}
Given two languages \AS{S} and \AS{T} and a similarity relation
\AS{\_\textasciitilde\_}
between them, \AS{S} and \AS{T} are in \textbf{simulation} if and only
if the following holds:
Given source language terms \AS{M} and \AS{N}, and a target language
term \AS{M‚Ä†} such that \AS{M} reduces to \AS{N} in a single step (\AS{M ‚Äî‚Üí N}) and
\AS{M} is similar to \AS{M‚Ä†} (\AS{M \~ M‚Ä†}), there exists a target
language term \AS{N‚Ä†} such that \AS{M‚Ä†} reduces to \AS{N‚Ä†} in some
number of steps (\AS{M‚Ä† ‚Äî‚Üí* N‚Ä†}) and \AS{N} is similar to \AS{N‚Ä†} (\AS{N \~ N‚Ä†}).
\end{definition}

\begin{definition}
Given two languages \AS{S} and \AS{T},  \AS{S} and \AS{T} are in a
\textbf{bisimulation} if and only if \AS{S} is in a simulation with \AS{T} and
\AS{T} is in a simulation with \AS{S}.
\end{definition}

The essence of simulation can be captured in a diagram.

TODO diagram here

TODO give names to the source and target langs

In fact, our source and target languages of closure conversion have a
stronger property: \textit{lock-step} bisimulation, which is defined
in terms of \textit{lock-step} simulations. A lock-step simulation is
one where for each reduction step of the source term, there is exactly
one corresponding reduction step in the target language. We illustrate
this at another diagram:

TODO another diagram

Before we can prove that Œª and ŒªT are in simulation, we need three
lemmas:

\begin{enumerate}
\item
  Values commute with similarity. If \AS{M \ti M‚Ä†} and \AS{M} is a
  value, then \AS{M‚Ä†} is also a value.

\item
  Renaming commutes with similarity. If \AS{œÅ} is a renaming from
  \AS{Œì} to \AS{Œî}, and \AS{M \ti M‚Ä†} are similar terms in the context
  \AS{Œì}, then the results of renaming \AS{M} and \AS{M‚Ä†} with \AS{œÅ}
  are also similar: \AS{S.rename œÅ M \ti T.rename œÅ M‚Ä†}.

\item
  Substitution commutes with similarity. Suppose \AS{œÅ} and \AS{œÅ‚Ä†} are two
  substitutions which take variables \AS{x} in \AS{Œì} to terms in \AS{Œî},
  such that for all \AS{x} we have that \AS{lookup œÅ x \ti lookup œÅ‚Ä†
    x}. Then given similar terms \AS{M \ti M‚Ä†} in \AS{Œì}, the results
  of applying \AS{œÅ} to \AS{M} and \AS{œÅ‚Ä†} to \AS{M‚Ä†} are also
  similar: \AS{S.subst œÅ M \ti T.subst œÅ‚Ä† M‚Ä†}.
\end{enumerate}

The proof that values commute with similarity is straightforward.

\ExecuteMetaData[StateOfTheArt/Bisimulation.tex]{val-comm} 

Before we will be able to prove the lemmas about renaming and substitution, we need an interlude
where we discuss so-called fusion lemmas for the closure language ŒªT.

TODO acknowledge PLFA here


\section{Fusion lemmas for the closure language ŒªT}

When studying the meta-theory of a calculus, one systematically needs
to prove fusion lemmas for various semantics (TODO wording) (recall
that a semantic is a traversal of a term). A fusion
lemma relates three semantics: the pair we sequence and their
sequential composition (TODO wording). In our proof of bimisulation
for closure conversion, we have interactions of two semantics:
renaming and substitution. In fact, we need fusion lemmas for all four
combinations of them:

\begin{enumerate}
  \item A renaming followed by a renaming,
  \item A renaming followed by a substitution,
  \item A substitution followed by a renaming,
  \item A substitution followed by a substitution.
  \end{enumerate}

As it turns out, the first composition (a renaming followed by a
renaming) is equivalent to a renaming, and the other three composition
are equivalent to substitutions.

We state the results as signatures of Agda functions, using the
environment combinators \AS{\_<\$>\_} and \AS{select} we described in Section~??.

\ExecuteMetaData[StateOfTheArt/Closure-Thms.tex]{rename-rename} 
\ExecuteMetaData[StateOfTheArt/Closure-Thms.tex]{rename-subst} 
\ExecuteMetaData[StateOfTheArt/Closure-Thms.tex]{subst-rename} 
\ExecuteMetaData[StateOfTheArt/Closure-Thms.tex]{subst-subst} 

Proofs of all four lemmas proceed

\section{Back to \ti rename and \ti subst}








% use the following and \cite{} as above if you use BibTeX
% otherwise generate bibtem entries
\bibliographystyle{plain}
\bibliography{main}

\end{document}
